#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double abs_double(double y)
{
    //Change this to return the absolute value of y i.e |y|
    double absy;
    absy = y;
    if (y < 0){
    absy = y * -1;
    }

    return absy;
}

double fx_val(double a, double b, double c, double d, double e, double x)
{
    //Change this to return the value of the polynomial at the value x
    //ax^4 + bx^3 + cx^2 + dx + e
double answer = a*pow(x,4) + b*pow(x,3) + c*pow(x,2)+d*x + e;
    return answer;
}

double fx_dval(double a, double b, double c, double d, double e, double x)
{
    //Change this to return the value of the derivative of the polynomial at the value x
    //4ax^3 + 3bx^2 + 2cx + d
double answer = 4*a*pow(x,3) + 3*b*pow(x,2) + 2*c*x + d;
    return answer;
}

double fx_ddval(double a, double b, double c, double d, double e, double x)
{
    //Change this to return the value of the double derivative of the polynomial at the value x
    //12ax^2 + 6bx + 2c
double answer = 12*a*pow(x,2) + 6*b*x + 2*c;
    return answer;
}


double newrfind_halley(double a, double b, double c, double d, double e, double x)
{
    //Change this to return the root found starting from the initial point x using Halley's method
    return 0;
}

int rootbound(double a, double b, double c, double d, double e, double r, double l)
{
    //int p_xl = a*pow(x,4) + ((4*a*l+b)*pow(x,3)) + ((6*a*pow(l,2)+3*b*l+c)*pow(x,2)) + ((4*a*pow(l,3)+3*b*pow(l,2)+2*c*l+d)*x) + (4*a*pow(l,4)+b*pow(l,3)+c*pow(l,2)+d*l+e);
    // for the x#sign variables, 1 corresponds to positive, 0 to negative, and -1 to zero.  -1 will be ignored
    int vl = 0;
    int i = 0;
    int lzero = 0;
    int ltotal = 0;
    int lx4sign = 0;
    int lx3sign = 0;
    int lx2sign = 0;
    int lxsign = 0;
    int lno_xsign = 0;
    int arraysignlength = 5;
    int lx4 = a;
    if (lx4 > 0){
        lx4sign = 1;
    }
    if(lx4==0){
        lx4sign = -1;
        lzero++;
    }
    if (lx4<0){
        lx4sign = 0;
    }
    int lx3 = 4*a*l+b;
    if (lx3>0){
        lx3sign = 1;
    }
    if(lx3==0){
        lx3sign = -1;
        lzero++;
    }
    if (lx3<0){
        lx3sign = 0;
    }
    int lx2 = 6*a*pow(l,2)+3*b*l+c;
    if (lx2 > 0){
        lx2sign = 1;
    }
    if (lx2==0){
        lx2sign = -1;
        lzero++;
    }
    if (lx2<0){
        lx2sign = 0;
    }
    int lx = 4*a*pow(l,3)+3*b*pow(l,2)+2*c*l+d;
    if (lx > 0){
        lxsign = 1;
    }
    if (lx == 0){
        lxsign = -1;
        lzero++;
    }
    if (lx < 0){
        lxsign = 0;
    }
    int lno_x = 4*a*pow(l,4)+b*pow(l,3)+c*pow(l,2)+d*l+e;
    if (lno_x > 0){
        lno_xsign = 1;
    }
    if (lno_x == 0){
        lno_xsign=-1;
        lzero++;
    }
    if (lno_x < 0){
        lno_xsign = 0;
    }
    arraysignlength = 5-lzero;
    if (arraysignlength <= 1){
    vl = 0;
    }
 int signarray[5] = {lx4sign, lx3sign,lx2sign,lxsign,lno_xsign};
 int signarrayfin[arraysignlength];
 int j = 0;
for (i = 0; i < arraysignlength; i++){
if (signarray[i]!= -1){
    signarrayfin[j]=signarray[i];
    printf("%n", signarrayfin[j]); //test
    j++;
                          }
} //at this point, we have the array so we can now do the calculation for v
int k = 0;

for (k = 0; k < arraysignlength-1;k++){
vl = vl + (signarrayfin[k]^signarrayfin[k+1]);
}
printf("vl is: %n",vl);

//////////////  END OF L SIDE
//////////////R SIDE BEGINS HERE

    int vr = 0;
    int l = 0; // instead of i,j,k we have l,m,n
    int rzero = 0;
    int rtotal = 0;
    int rx4sign = 0;
    int rx3sign = 0;
    int rx2sign = 0;
    int rxsign = 0;
    int rno_xsign = 0;
    int arraysignrength = 5;
    int rx4 = a;
    if (rx4 > 0){
        rx4sign = 1;
    }
    if(rx4==0){
        rx4sign = -1;
        rzero++;
    }
    if (rx4<0){
        rx4sign = 0;
    }
    int rx3 = 4*a*r+b;
    if (rx3>0){
        rx3sign = 1;
    }
    if(rx3==0){
        rx3sign = -1;
        rzero++;
    }
    if (rx3<0){
        rx3sign = 0;
    }
    int rx2 = 6*a*pow(r,2)+3*b*r+c;
    if (rx2 > 0){
        rx2sign = 1;
    }
    if (rx2==0){
        rx2sign = -1;
        rzero++;
    }
    if (rx2<0){
        rx2sign = 0;
    }

    int rx = 4*a*pow(r,3)+3*b*pow(r,2)+2*c*r+d;
if (rx > 0){
        rxsign = 1;
    }
    if (rx == 0){
        rxsign = -1;
        rzero++;
    }
    if (rx < 0){
        rxsign = 0;
    }
    int rno_x = 4*a*pow(r,4)+b*pow(r,3)+c*pow(r,2)+d*r+e;
    if (rno_x > 0){
        rno_xsign = 1;
    }
    if (rno_x == 0){
        rno_xsign=-1;
        rzero++;
    }
    if (rno_x < 0){
        rno_xsign = 0;
    }

arraysignrength = 5-rzero;
    if (arraysignrength <= 1){
    vr = 0;
    }
 int signarrayr[5] = {rx4sign, rx3sign,rx2sign,rxsign,rno_xsign};
 int signarrayfinr[arraysignrength];
 int m = 0;

for (l = 0; l < arraysignrength; l++){
if (signarrayr[l]!= -1){
    signarrayfinr[m]=signarrayr[l];
    printf("%n", signarrayfinr[m]); //test
    m++;
                          }
} //at this point, we have the array so we can now do the calculation for v
int n = 0;

for (n = 0; n < arraysignrength-1;n++){
vr = vr + (signarrayfinr[n]^signarrayfin[n+1]);
}
printf("vr is: %n",vr);

int vlvr_diff = 0;
vlvr_diff = vl - vr;
vlvr_diff = abs_double((double)vlvr_diff);

    //ax4+(4al+b)x3+(6al2+3bl+c)x2+(4al3+3bl2+2cl+d)x+(al4+bl3+cl2+dl+e)
    //Change this to return the upper bound on the number of roots of the polynomial in the interval (l, r)
    return vlvr_diff;
}

int main(int argc, char **argv)
{
	double a, b, c, d, e, l, r;
	FILE *in;

	if (argv[1] == NULL) {
		printf("You need an input file.\n");
		return -1;
	}
	in = fopen(argv[1], "r");
	if (in == NULL)
		return -1;
	fscanf(in, "%lf", &a);
	fscanf(in, "%lf", &b);
	fscanf(in, "%lf", &c);
	fscanf(in, "%lf", &d);
	fscanf(in, "%lf", &e);
	fscanf(in, "%lf", &l);
	fscanf(in, "%lf", &r);

    //The values are read into the variable a, b, c, d, e, l and r.
    //You have to find the bound on the number of roots using rootbound function.
    //If it is > 0 try to find the roots using newrfind function.
    //You may use the fval, fdval and fddval funtions accordingly in implementing the halleys's method.


    fclose(in);

    return 0;
}
