/*
 *
 shung5
 ece220
 mp6
 version 0.6




 countLiveNeighbor
 * Inputs:
 * board: 1-D array of the current game board. 1 represents a live cell.
 * 0 represents a dead cell
 * boardRowSize: the number of rows on the game board.
 * boardColSize: the number of cols on the game board.
 * row: the row of the cell that needs to count alive neighbors.
 * col: the col of the cell that needs to count alive neighbors.
 * Output:
 * return the number of alive neighbors. There are at most eight neighbors.
 * Pay attention for the edge and corner cells, they have less neighbors.
 */

int countLiveNeighbor(int* board, int boardRowSize, int boardColSize, int row, int col){
int rowsize = boardRowSize;
int colsize = boardColSize;
int endindex = rowsize * colsize - 1; //remember that rows and column indexes start at 0
int totalalive = 0;
int currentpos = row * colsize + col;
int north, south, east, west, northeast, northwest, southeast, southwest; //these are the eight possible neighbors

//check north buddy
north = currentpos - rowsize;
if (north >= 0){ //check to see if north neighbor exists
    if (board[north]==1){
        totalalive++;
    }
}
//check south buddy
south = currentpos + rowsize;
if (south <= endindex){ //this must be true in order for us to check the following conditional
    if (board[south]==1){ //above must be true in order for this case
        totalalive++;
    }
}
//check east buddy
east = currentpos + 1;
if (east <= endindex){
    if (currentpos%rowsize != (rowsize-1) && board[east] == 1){ //check to see if the current cell is a right edge cell
        totalalive++;
         }
}
//check west buddy
west = currentpos - 1;
if (west >= 0){
    if (currentpos%rowsize!=0 && board[west]==1){ //check to see if the current cell is left edge cell
        totalalive++;
            }
}
//check northeast buddy
northeast = currentpos - (rowsize -1);
if (northeast >= 0){ //if in range
    if (currentpos%rowsize!=(rowsize - 1) && board[northeast]==1){ //check to see if right edge cell
            totalalive++;
        }
}
//check northwest buddy
northwest = currentpos - (rowsize + 1);
if (northwest >= 0){
    if (currentpos%rowsize!=0 && board[northwest]==1){
            totalalive++;
        }
    }
//check southeast buddy
southeast = currentpos + (rowsize + 1);
if (southeast <= endindex){
    if (currentpos%rowsize != (rowsize - 1) && board[southeast]==1){ //check for right edge cell
           totalalive++;
        }

}
//check southwest buddy
southwest = currentpos + (rowsize-1);
if (southwest <= endindex){
    if (currentpos%rowsize!=0 && board[southwest]==1){
            totalalive++;
        }
    }

return totalalive;
}



/*
 * Update the game board to the next step.
 * Input:
 * board: 1-D array of the current game board. 1 represents a live cell.
 * 0 represents a dead cell
 * boardRowSize: the number of rows on the game board.
 * boardColSize: the number of cols on the game board.
 * Output: board is updated with new values for next step.
 */
int updateBoard(int* board, int boardRowSize, int boardColSize) {
int i = 0;
int j = 0;
int k = 0;
int rowsize = boardRowSize;
int colsize = boardColSize;
int liveneighbors = countLiveNeighbor(*board, rowsize, colsize, i, j);
for (i = 0; i < colsize; i++){ //keeps track of row
    for (j = 0; j < rowsize; j++){ //keeps track of column
            if (board[k]==1){ //if alive
                if (liveneighbors!=2 && liveneighbors!=3  ){
                    board[k] = 0;
                }
            }
            if (board[k]==0){ //if dead
                if (liveneighbors==3){ //if dead cell has exactly three neighbors
                    board[k] = 1;
                }
            }
        k++; //move to next cell
        }
    }


return *board; //return updated board
}





/*
 * aliveStable
 * Checks if the alive cells stay the same for next step
 * board: 1-D array of the current game board. 1 represents a live cell.
 * 0 represents a dead cell
 * boardRowSize: the number of rows on the game board.
 * boardColSize: the number of cols on the game board.
 * Output: return 1 if the alive cells for next step is exactly the same with
 * current step or there is no alive cells at all.
 * return 0 if the alive cells change for the next step.
 */
int aliveStable(int* board, int boardRowSize, int boardColSize){
//perhaps try to use & to and the two arrays together (current and next)
//if the anded result is equivalent to the current, then the alive cells are the same
//if this is the case, return 1
int rowsize = boardRowSize;
int colsize = boardColSize;
int added = 0;
added = *board & updateBoard(*board, rowsize, colsize);
int stable = 0;
if (added == *board){
    stable = 1;
}
return stable;
}





